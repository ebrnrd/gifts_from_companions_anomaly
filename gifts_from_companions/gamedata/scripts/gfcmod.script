-- CREDITS
-- thanks to Thanks to Darkasleif and their Chatty Companions Addon that I used to figure out what I was even doing.
-- thanks to forsiid for the russian translations.


-- SETTINGS --
local max_timer --min time between gifts
local min_timer --max time between gifts
local gift_chance -- chance to receive gift
local friendship_timer -- time between passive friendship increment
local friendship_on_npc_death
local friendship_on_monster_death
local friendship_on_companion_death
local hide_friendship_messages = false
local debug_mode = false

-- CONSTANTS --
local show_time = 3000 -- how long the notifications stay on the screen
local max_gift_distance = 30 --max distance from companion to player to give gift
local max_friendship = 100
local random_messages_number = 5 -- the total number of gift phrases in st_gfcmod_messages.xml

local clr_g = utils_xml.get_color("d_green")
local clr_w = utils_xml.get_color("white")

-- VARIABLES --
local current_friendship = 0 --this is only used by gfcmod_tables to get the friendship because using gfcmod_cache_tbl.friendship crashes the game
local temp_friendship = 0 -- value that accumulates while in combat and used to calculate the friendship once combat has ended
local enemy_table = {} -- table to store enemies around player
local npc_was_enemy 
local area_clear
local n = 1
local is_first_load = false
local gt = game.translate_string

local gfcmod_cache_tbl = {} --table with persistent data (friendship, tg_target, tg_friendship_target, tg_last)

-- FUNCTIONS --

function save_state(m_data)
    m_data.gfcmod_cache_tbl = gfcmod_cache_tbl
end

function load_state(m_data)
    gfcmod_cache_tbl = m_data.gfcmod_cache_tbl or {}
end

function on_option_change()
    load_gfc_settings()
    calculate_tg_target()
    calculate_tg_friendship_target()
end

function on_game_load()
    load_gfc_settings()
end

function load_gfc_settings()
    min_timer = gfcmod_mcm.get_config("min_timer")
    max_timer = gfcmod_mcm.get_config("max_timer")
    gift_chance = gfcmod_mcm.get_config("gift_chance")
    friendship_timer = gfcmod_mcm.get_config("friendship_timer")
    friendship_on_npc_death = gfcmod_mcm.get_config("friendship_on_npc_death")
    friendship_on_monster_death = gfcmod_mcm.get_config("friendship_on_monster_death")
    friendship_on_companion_death = gfcmod_mcm.get_config("friendship_on_companion_death")
    hide_friendship_messages = gfcmod_mcm.get_config("hide_friendship_messages")
    debug_mode = gfcmod_mcm.get_config("debug_mode")
end

function get_random_companion()
    if axr_companions.get_companion_count() == 0 then
        return
    end
    local companions_table = axr_companions.list_actor_squad_by_id()
    return level.object_by_id(companions_table[math.random(#companions_table)])
end

function get_passive_friendship_increment()
    local friendship_passive_increment = 0
    local companions_count = axr_companions.get_companion_count()
    if companions_count == 0 then
        return 0
    end
    friendship_passive_increment = companions_count
    return friendship_passive_increment
end

function add_friendship(friendship_to_add, type)

    local msg 

    if friendship_to_add == 0 then
        return
    end

    if friendship_to_add > 0 then
        gfcmod_cache_tbl.friendship = gfcmod_cache_tbl.friendship + friendship_to_add
        if gfcmod_cache_tbl.friendship > max_friendship then
            gfcmod_cache_tbl.friendship = max_friendship
        end
        if not type then
            msg = clr_g .. gt("st_gfcmod_friendship_increase_basic") .. " " .. clr_w .. gfcmod_cache_tbl.friendship .. "/" .. max_friendship
        else 
            msg = clr_g .. gt("st_gfcmod_friendship_increase_" .. type) .. " " .. clr_w .. gfcmod_cache_tbl.friendship .. "/" .. max_friendship
        end            
    end
    
    if friendship_to_add < 0 then
        gfcmod_cache_tbl.friendship = gfcmod_cache_tbl.friendship + friendship_to_add
        if gfcmod_cache_tbl.friendship < 0 then
            gfcmod_cache_tbl.friendship = 0
        end
        if not type then
            msg = clr_w .. gt("st_gfcmod_friendship_decrease_basic") .. " " .. clr_w .. gfcmod_cache_tbl.friendship .. "/" .. max_friendship
        else 
            msg = clr_w .. gt("st_gfcmod_friendship_decrease_" .. type) .. " " .. clr_w .. gfcmod_cache_tbl.friendship .. "/" .. max_friendship
        end 
    end

    if not hide_friendship_messages then
        news_manager.send_tip(db.actor, msg, nil, nil, show_time)
    end
    
    current_friendship = gfcmod_cache_tbl.friendship
end

function calculate_tg_target()
    local tg = time_global()
    gfcmod_cache_tbl.tg_target = tg + math.random(min_timer*1000, max_timer*1000)
end

function calculate_tg_friendship_target()
    local tg = time_global()
    gfcmod_cache_tbl.tg_friendship_target = tg + friendship_timer*1000
end

function get_current_friendship()
    return current_friendship
end

function get_current_friendship_stage()
    if gfcmod_cache_tbl.friendship <= 25 then
        return "bad"
    end
    if gfcmod_cache_tbl.friendship <= 50 then
        return "normal"
    end
    if gfcmod_cache_tbl.friendship <= 75 then
        return "good"
    end
    if gfcmod_cache_tbl.friendship <= 100 then
        return "excellent"
    end
end

-- code straight up copied from Chatty Companions addon by Darkasleif

function on_enemy_eval(obj, enemy)
    local id = enemy:id()
    if enemy_table[id] or not obj:has_info("npcx_is_companion") or not is_enemy(enemy, db.actor, false) then
        return
    end

    enemy_table[id] = true
end

function is_enemy(obj, who, memory) 
    -- If obj exists
    if not obj then
        return false
    end

    -- If obj and who are the same
    if obj:id() == who:id() then
        return false
    end

    -- If obj is a crow
    if (obj:clsid() == clsid.crow) then
		return false 
	end

    -- If obj is not a mutant or stalker
    if not IsMonster(obj) and not IsStalker(obj) then
        return false
    end

    -- If obj is dead
    if not obj:alive() then
        return false
    end

    if IsStalker(obj) and ((who:id() == 0) or (who:id() == AC_ID)) then
        local relation = relation_registry.community_relation(character_community(obj), gameplay_disguise.get_default_comm())
        local goodwill = relation_registry.community_goodwill(character_community(obj), db.actor:id())
        -- If faction is not enemy and not fighting with actor
        if not game_relations.is_factions_enemies(obj:character_community(), character_community(db.actor):sub(7)) and not xr_combat_ignore.fighting_with_actor_npcs[obj:id()] then
            return false
        end

        -- If obj is companion and not pissed off
        if obj:has_info("npcx_is_companion") and not xr_combat_ignore.fighting_with_actor_npcs[obj:id()] then
            return false
        end

        -- if not gameplay_disguise.is_actor_disguised() and relation + goodwill >= 0 and not xr_combat_ignore.fighting_with_actor_npcs[obj:id()] then
        --     return false
        -- end

        -- If player bribe is in effect
        if xr_bribe.at_peace(character_community(obj), gameplay_disguise.get_default_comm(), obj:position():distance_to(db.actor:position())) and not xr_combat_ignore.fighting_with_actor_npcs[obj:id()] then
            return false
        end

        -- If "Rostok Under Duty Control" installed
        if gameplay_peace_zone and level.name() == "l05_bar" and character_community(db.actor):sub(7) == "army" and (character_community(obj) == "csky" or character_community(obj) == "stalker") and not xr_combat_ignore.fighting_with_actor_npcs[obj:id()] then
            return false
        end

        -- If obj has forgotten who
        if memory then
            local tg = time_global()
            local time_in_memory = tg - obj:memory_time(who)
            if (time_in_memory < 0) then
                if (time_in_memory < -120000) or (time_in_memory < -60000) then
                    return false 
                end
            else 
                if (time_in_memory > 120000) or (time_in_memory > 60000) then
                    return false
                end
            end
        end
    end

    if IsStalker(obj) then
        if npc_surrendered(obj) then
            return false
        end
    end

	return true
end

function npc_surrendered(npc)
	local st = db.storage[npc:id()]
	return st and st.victim_surrender and st.victim_surrender >= 0 and st.victim_surrender < 65534 or false
end

function npc_on_death_callback(obj)
    local id = obj:id()
    stored_id = obj:id()
    if enemy_table[id] then
        table.remove(enemy_table, id)
        npc_was_enemy = true
    else
        npc_was_enemy = false
    end

    if obj:has_info("npcx_is_companion") then
        if friendship_on_companion_death then
            temp_friendship = temp_friendship - friendship_on_companion_death
        end
    end

    if npc_was_enemy then
        if friendship_on_npc_death then
            temp_friendship = temp_friendship + friendship_on_npc_death
        end
    end
end

function monster_on_death_callback(obj)
    id = obj:id()
    stored_id = obj:id()
    if enemy_table[id] then
        table.remove(enemy_table, id)
        npc_was_enemy = true
    else
        npc_was_enemy = false
    end

    if npc_was_enemy then
        if friendship_on_monster_death then
            temp_friendship = temp_friendship + friendship_on_monster_death
        end
    end
end

function in_combat()
    area_clear = true
    level.iterate_nearest(db.actor:position(), 50, iterate_func_clear)
    return not area_clear
end

function iterate_func_clear(obj)
    if stored_id ~= obj:id() and obj:id() ~= 0 and is_enemy(obj, db.actor, true) then
        area_clear = false
    end
end

function actor_on_first_update()
    if not gfcmod_cache_tbl.tg_target or gfcmod_cache_tbl.tg_target == 0 then
        gfcmod_cache_tbl.tg_target = 0
        calculate_tg_target()
    elseif is_first_load and gfcmod_cache_tbl.tg_last and gfcmod_cache_tbl.tg_last ~= 0 then
        local tg = time_global()
        gfcmod_cache_tbl.tg_target = gfcmod_cache_tbl.tg_target - (gfcmod_cache_tbl.tg_last - tg)
    end
        
    if not gfcmod_cache_tbl.tg_friendship_target or gfcmod_cache_tbl.tg_friendship_target == 0 then
        gfcmod_cache_tbl.tg_friendship_target = 0
        calculate_tg_friendship_target()
    elseif is_first_load and gfcmod_cache_tbl.tg_last and gfcmod_cache_tbl.tg_last ~= 0 then
        local tg = time_global()
        gfcmod_cache_tbl.tg_friendship_target = gfcmod_cache_tbl.tg_friendship_target - (gfcmod_cache_tbl.tg_last - tg)
    end

    if not gfcmod_cache_tbl.friendship or gfcmod_cache_tbl.friendship == 0 then
        gfcmod_cache_tbl.friendship = 0
    end

    is_first_load = false

end

function actor_on_update()
    
    n = n + 1
    
    if n ~= 666 then --update frequency
        return
    end

    n = 1
    local tg = time_global()
    
    gfcmod_cache_tbl.tg_last = tg -- the engine everytime the actual game is opened, resets the global times, this helps to calculate the delta from the tg from last session
   
    if debug_mode then  -- DEBUGGING
        local msg_debug = clr_g .. "current time: " .. tg .. " ".. "gift time: " .. gfcmod_cache_tbl.tg_target
        news_manager.send_tip(db.actor, msg_debug, nil, nil, show_time)
        local msg_debug = clr_g .. "current time: " .. tg .. " ".. "friendship time: " .. gfcmod_cache_tbl.tg_friendship_target
        news_manager.send_tip(db.actor, msg_debug, nil, nil, show_time)
    end

    if axr_companions.get_companion_count() == 0 then
        gfcmod_cache_tbl.friendship = 0
        current_friendship = gfcmod_cache_tbl.friendship
        return
    end

    if temp_friendship and temp_friendship ~= 0 and not in_combat() then
        add_friendship(temp_friendship, nil)
        temp_friendship = 0
    end

    if tg >= gfcmod_cache_tbl.tg_friendship_target then
        
        local friendship_increment = get_passive_friendship_increment()
        add_friendship(friendship_increment, "passive")
        calculate_tg_friendship_target()
    end

    if tg >= gfcmod_cache_tbl.tg_target and area_clear then
        local rnd_companion = get_random_companion()
        if not rnd_companion or rnd_companion:id() == 0 or distance_between(db.actor,rnd_companion) > max_gift_distance then
            return
        end
        if math.random() <= gift_chance then
            local random_gift = gfcmod_tables.get_random_gift()
            local msg = clr_g .. rnd_companion:character_name() .. ": " .. clr_w .. gt("st_gfcmod_".. get_current_friendship_stage() .. math.random(1, random_messages_number))
            news_manager.send_tip(db.actor, msg, nil, rnd_companion, show_time, rnd_companion:id())
            alife_create_item(random_gift, alife():object(0))
            news_manager.relocate_item(db.actor, "in", random_gift, 1)
        end
        calculate_tg_target()
    end

end

-- TASK SYSTEM

xr_effects.setup_fetch_task = function(actor,npc,p) -- setup_supplies_fetch_task
    -- Pick a random item from the list:
    -- param 1 - var name
    -- param 2 - items type
    -- param 2 - min count
    -- param 3 - max count
    
        local npc = get_random_companion()
        local id  = npc and npc:id()
        local sec = DIALOG_ID[id] and DIALOG_ID[id][p[1]] and DIALOG_ID[id][p[1]].sec
        local cnt = DIALOG_ID[id] and DIALOG_ID[id][p[1]] and DIALOG_ID[id][p[1]].cnt
        
        if (sec and ini_sys:section_exist(sec) and cnt) then
            dialogs._FETCH_TEXT = ui_item.get_sec_name(sec)
            save_var( db.actor, p[1], sec )
            save_var( db.actor, (p[1] .. "_count"), cnt )
    
        else
            local npc_comm = npc and character_community(npc) or "stalker"
            local npc_rank = ranks.get_obj_rank_name(npc) or "experienced"
            
            local itms = {} -- non-key table
            
            -- expand supplies list to include drinks and smoke if the task giver is not monolith
            if (p[2] == "supplies") and (npc_comm ~= "monolith") then
                itms = fetch_items["supplies"]
                for sec,tier in pairs(fetch_items["drink"]) do
                    itms[sec] = tier
                end
                
            -- Gather patches of NPC's enemy factions
            elseif (p[2] == "patch_general") then
                local patches = {}
                for i=1,#faction_lookup do
                    if game_relations.is_factions_enemies(faction_lookup[i], npc_comm) then
                        local comm
                        if (faction_lookup[i] == "killer") then comm = "merc"
                        elseif (faction_lookup[i] == "dolg") then comm = "duty"
                        else comm = faction_lookup[i]
                        end
                        
                        local patch =  comm .. "_patch"
                        patches[patch] = 0
                    end
                end
                
                if is_empty(patches) then
                    patches = patch_general[npc_comm]
                end
                
                itms = patches
            
            -- Gather suitable repair kits
            elseif (p[2] == "repair") then
            
                -- Get NPC's weapon
                local obj_wep = npc:best_weapon()
                local sec_wep = obj_wep and obj_wep:section()
                
                -- Gather proper repair kits
                local repair_kits = {
                    ["sharpening_stones"] = 0,
                    ["sewing_kit_b"] = 0,
                }
                if sec_wep then
                    local wep_type = ini_sys:r_string_ex(sec_wep,"repair_type") or ""
                    for sec,tier in pairs(fetch_items["repair"]) do
                        local kit_type = parse_list(ini_sys,sec,"repair_only",true)
                        if kit_type[wep_type] then
                            repair_kits[sec] = tier
                        end
                    end
                end
                
                itms = repair_kits
                
            -- Gather suitable weapons
            elseif (p[2] == "weapons") then
                local f = faction_expansions.faction[npc_comm]
                local npc_preference = f and f["weapon"] or ""
                
                -- Collects weapons suitable for npc rank
                local wpn_by_rank = {}
                if fetch_items["weapons_" .. npc_rank] then
                    local tbl = fetch_items["weapons_" .. npc_rank]
                    for sec,tier in pairs(tbl) do
                        wpn_by_rank[sec] = tier
                    end
                end
                
                -- Collects weapons suitable for npc faction
                local wpn_by_ref = {}
                if fetch_items["weapons_" .. npc_preference] then
                    local tbl = fetch_items["weapons_" .. npc_preference]
                    for sec,tier in pairs(tbl) do
                        wpn_by_ref[sec] = tier
                    end
                end
                
                -- collect suitable weapons
                local wpns = {}
                for sec,tier in pairs(wpn_by_rank) do
                    if wpn_by_ref[sec] then
                        wpns[sec] = tier
                    end
                end
                for sec,tier in pairs(wpn_by_ref) do
                    if wpn_by_rank[sec] then
                        wpns[sec] = tier
                    end
                end
                
                if is_not_empty(wpns) then
                    itms = wpns
                else
                    itms = fetch_items["weapons"]
                end
            else
                itms = fetch_items[p[2]]
            end
            
            if not (itms and is_not_empty(itms)) then
                printe("! ERROR: %s | fetch list [%s] is invalid", p[1], p[2])
            end
            
            local min_count = (p[3] and tonumber( p[3] ) or 1)
            local max_count = (p[4] and tonumber( p[4] ) or min_count)
            sec = get_suitable_item(itms, npc_rank) or random_key_table(itms)
            cnt = math.random( min_count, max_count )
        
            -- Save chosen fetch item:
            if (not DIALOG_ID[id]) then DIALOG_ID[id] = {} end
            if (not DIALOG_ID[id][p[1]]) then DIALOG_ID[id][p[1]] = {} end
            
            DIALOG_ID[id][p[1]].sec = sec
            DIALOG_ID[id][p[1]].cnt = cnt
            dialogs._FETCH_TEXT = ui_item.get_sec_name(sec)
            save_var( db.actor, p[1], sec )
            save_var( db.actor, (p[1] .. "_count"), cnt )
            
        end
        
        CreateTimeEvent(0,"setup_fetch_task", 0, postpone_fetch_for_next_frame, p[1], sec, cnt)
    end


--================== CALLBACKS =====================
function on_game_start()
    RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
    RegisterScriptCallback("actor_on_update", actor_on_update)
    RegisterScriptCallback("on_game_load", on_game_load)
    RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("save_state",save_state)
	RegisterScriptCallback("load_state",load_state)
    RegisterScriptCallback("npc_on_death_callback", npc_on_death_callback)
    RegisterScriptCallback("monster_on_death_callback", monster_on_death_callback)
    RegisterScriptCallback("on_enemy_eval", on_enemy_eval)   

    is_first_load = true

end